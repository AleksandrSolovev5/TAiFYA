# Сравнение Python и JavaScript 

* JavaScript традиционно используется в браузерах для фронтенда и веб-интерфейсов 
* Python чаще применяют для бэкенда и анализа данных

---

## 1. Синтаксис циклов, ветвлений, блоков кода

* **Python**

  * Циклы: `for … in range()`, `while`
  * Ветвления: `if … elif … else`
  * Блоки определяются отступами
* **JavaScript**

  * Циклы: `for`, `while`, `for…of`, `for…in`
  * Ветвления: `if … else if … else`
  * Блоки заключаются в `{}`

**Вывод:** Python проще визуально, но JS поддерживает больше форм циклов.

---

## 2. Способ объявления переменных и параметров

* **Python**

  * Нет явного объявления типов переменных
  * Всё динамически типизировано
  * Аргументы функций можно задавать позиционно и по имени
  * **Нет констант** - используются соглашения (UPPER_CASE) но технически изменяемы
  
* **JavaScript**
  * `var` — устаревший вариант
  * `let` — переменная в блоке
  * `const` — константа
  * Функции принимают параметры без явного типа, можно задавать значения по умолчанию

---

## 3. Типы данных

| Категория  | Python                                       | JavaScript                            |
| ---------- | -------------------------------------------- | ------------------------------------- |
| Числа      | `int` (расширяемый), `float`, `complex`      | `Number` (64 бит), `BigInt` |
| Строки     | `str`                                        | `String`                              |
| Логические | `bool` (`True/False`)                        | `Boolean` (`true/false`)              |
| Коллекции  | `list`, `tuple`, `set`, `dict`               | `Array`, `Set`, `Map`, `Object`       |
| None/Null  | `None`                                       | `null`, `undefined`                   |

**Особенности:**

* Python int — arbitrary-precision integer: автоматически расширяется (нет переполнения, ограничение — память).
* JS имеет единственный тип чисел `Number`, для очень больших значений используется `BigInt`.
* В JS есть два "пустых" значения: `null` и `undefined`.

---

## 4. Набор операторов

| Группа         | Python            | JavaScript                |
| -------------- | ----------------- | ------------------------- |
| Арифметические | `+ - * / // % **` | `+ - * / % **`            |
| Сравнения      | `== != > < >= <=` | `== === != !== > < >= <=` |
| Логические     | `and or not`      | `&&  \|\| ! `             |
| Побитовые      | `& \| ^ ~ << >>`  | `& \| ^ ~ << >> >>>`      |


**Особенности:**

* В JS различают строгие (`===`) и нестрогие (`==`) сравнения.
* Python всегда использует строгую проверку равенства.

---

## 5. Пользовательские функции

* **Python**

  ```python
  def f(a, b=0):
      return a + b
  ```

  * Определение через ключевое слово def
  * Возможны значения параметров по умолчанию (b=0)

* **JavaScript**

  ```javascript
  function f(a, b=0) { return a + b; }
  
  const f2 = (a, b) => a + b;
  ```

  * Определение через function или стрелочный синтаксис ()=>
  * Функции — объекты, можно передавать как значения

---

## 6. Пользовательские структуры

* **Python**

  * `class`, `dataclass`, `namedtuple`
  * Поддержка множественного наследования
* **JavaScript**

  * `class`, объектные литералы `{}`, конструкторы
  * Прототипное наследование, `class` — синтаксическая обёртка

---

## 7. Управление памятью

* **Python**

  * Автоматический сборщик мусора
  * Поддержка подсчёта ссылок и сборки циклов
* **JavaScript**

  * Автоматический сборщик мусора
  * Замыкания могут удерживать ненужные объекты
* **Особенность:** в JS важно явно разрывать ссылки в обработчиках событий, чтобы избежать утечек.

---

## 8. Обработка ошибок

* **Python**

  ```python
  try:
    x = int("abc")
  except ValueError:
    print("Ошибка преобразования в число")
  finally:
    print("Завершение блока")
  ```
* **JavaScript**

  ```javascript
  try {
    let x = parseInt("abc");
    if (isNaN(x)) throw new Error("Ошибка преобразования в число");
  } catch (e) {
    console.log(e.message);
  } finally {
    console.log("Завершение блока");
  }
  ```

**Различие:**

* Python: четкие типы исключений; можно ловить конкретные (except ValueError:).

* JS: ошибки как объекты; часто используют ручные проверки и throw new Error(...).

---

## 9. Компиляция языков
Python - интерпретатор с байт-кодом

### **Архитектура CPython:**
```
.py файл → Лексер → Токены → Парсер → AST → Компилятор → Байт-код → Виртуальная машина
```

### **Ключевые компоненты:**

**1. Лексер (лексческий анализ)**
```python
# Исходник: x = 10 + 20
# Токены: [IDENTIFIER:x, EQUALS, NUMBER:10, PLUS, NUMBER:20]
```

**2. Парсер (синтаксический анализ)**
- Строит AST (Abstract Syntax Tree)
- Проверяет грамматику Python

**3. Компилятор байт-кода**
```python
import dis
def example():
    x = 10 + 20

dis.dis(example)
# 0 LOAD_CONST   1 (30)   # Сразу 10+20=30!
# 3 STORE_FAST    0 (x)


---

## JavaScript - JIT-компиляция в машинный код

### **Архитектура V8:**
```
.js файл → Парсер → AST → Интерпретатор Ignition → Байт-код → Профилирование → JIT TurboFan → Машинный код
```

### **Ключевые компоненты:**

**1. Парсер + AST**
- Быстрый парсинг, отложенная компиляция функций

**2. Интерпретатор Ignition**
- Быстрый старт через байт-код
- Сбор данных для оптимизации

**3. JIT-компилятор TurboFan**
```javascript
function hotFunction(a, b) {
    return a + b;  // После 10+ вызовов → машинный код!
}
```
---

## Сравнение выполнения

### **Python:**
```python
def calculate(x, y):
    return x * y + 10

# Каждый вызов:
# 1. Поиск в namespace
# 2. Вызов функции
# 3. Интерпретация байт-кода
# 4. Диспетчеризация операций
```

### **JavaScript:**
```javascript
function calculate(x, y) {
    return x * y + 10;
}

// Первые вызовы: интерпретация байт-кода
// После профилирования: нативный машинный код
```

---

## Ключевые отличия

| Аспект | Python | JavaScript |
|--------|--------|------------|
| **Выполнение** | Интерпретация байт-кода | JIT в машинный код |
| **Параллелизм** | GIL ограничивает | Event loop + Workers |
| **Оптимизации** | Минимальные | Агрессивные JIT |
| **Портативность** | Байт-код переносим | Машинный код специфичен |

**Итог:** Python интерпретирует байт-код виртуальной машиной, JavaScript JIT-компилируется в нативный код процессора.
## Вывод

* **Python**

  * Более читаемый синтаксис
  * Богатый набор встроенных типов
  * Удобные инструменты для рекурсии и тестирования
  * Огромное количество различных библиотек
* **JavaScript**

  * Стандарт для браузера
  * Гибкие циклы и работа с функциями как объектами
  * Универсальный тип `Number`, но с ограничениями точности
  * Высокая производительность благодаря JIT, настоящая асинхронность

**Итог:**

* Python очень универсален ( для создания парсера, математики, обучения ИИ, анализа удобнее будет Python).
* Для фронтенда  — JavaScript без альтернатив.
