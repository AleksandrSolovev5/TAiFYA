# Лексическая структура: Python vs JavaScript

## 1. Элементы структурного программирования

### 1.1 Блоки кода

| Аспект | Python | JavaScript |
|---|---:|---|
| Как обозначается блоки | Отступы (значимы) | Фигурные скобки `{}` |
| Токены, генерируемые лексером | INDENT / DEDENT при смене уровня отступа | `{` и `}` как обычные токены |
| Примечание | Новая строка часто завершает логическую инструкцию; вложенность — по стеку отступов | Блоки явные; новая строка не всегда завершает инструкцию (ASI в JS) |

**INDENT / DEDENT — пояснение (для лексера):**  
Лексер Python отслеживает уровень пробелов/табов в начале строк. При увеличении уровня он порождает INDENT; при уменьшении — серию DEDENT. Это позволяет парсеру понимать начало и конец блоков без фигурных скобок. NEWLINE — токен, который обычно сообщает об окончании логической строки; однако внутри скобок или внутри многострочных строк переносы не генерируют NEWLINE.

**Пример — Python**
```python
def f():
    if x > 0:
        print(x)
    print('done')
```

**Пример — JavaScript**
```javascript
function f() {
  if (x > 0) {
    console.log(x);
  }
  console.log('done');
}
```

---

### **1.2 Ветвления**

В обоих языках ветвления определяют логику выполнения по условию, но синтаксис и оформление блоков отличаются.

| Элемент              | **Python**                                                        | **JavaScript**                                               |
| -------------------- | ----------------------------------------------------------------- | ------------------------------------------------------------ |
| Ключевые слова       | `if`, `elif`, `else`                                              | `if`, `else if`, `else`                                      |
| Блоки кода           | Определяются **отступами** (INDENT / DEDENT)                      | Заключаются в **фигурные скобки `{}`**                       |
| Условие              | Не требует скобок                                                 | Требует круглые скобки `()`                                  |
| Истинность выражений | Использует концепцию **truthy / falsy** (0, `None`, `''` → False) | Аналогично, но дополнительно автоматическое приведение типов |

**Примеры**

**Python:**

```python
x = 10
if x > 0:
    print("Положительное")
elif x == 0:
    print("Ноль")
else:
    print("Отрицательное")
```

**JavaScript:**

```javascript
let x = 10;
if (x > 0) {
  console.log("Положительное");
} else if (x === 0) {
  console.log("Ноль");
} else {
  console.log("Отрицательное");
}
```

**Вывод:**
Python делает синтаксис визуально чище, JavaScript — более формален и требует явных скобок.

---

### **1.3 Циклы**

Оба языка поддерживают **итерационные** и **условные** циклы, но различаются по конструкции.

| Тип цикла     | **Python**                  | **JavaScript**                |
| ------------- | --------------------------- | ----------------------------- |
| Итерационный  | `for x in iterable:`        | `for (let i = 0; i < n; i++)` |
| По коллекциям | `for item in list:`         | `for (const item of array)`   |
| По ключам     | `for key in dict:`          | `for (const key in object)`   |
| Условный      | `while condition:`          | `while (condition) { ... }`   |
| Прерывание    | `break`, `continue`, `else` | `break`, `continue`           |

**Примеры**

**Python:**

```python
for i in range(3):
    print("Итерация", i)
else:
    print("Цикл завершён")
```

**JavaScript:**

```javascript
for (let i = 0; i < 3; i++) {
  console.log("Итерация", i);
}
console.log("Цикл завершён");
```

**Вывод:**
Python поддерживает конструкцию `for...else`, которой нет в JavaScript.
JS же имеет больше синтаксических форм (`for...of`, `for...in`, `while`, `do...while`).
---

## 2. Средства для ввода/вывода и другие встроенные функции

> Лексически это идентификаторы и последовательности токенов (точка, скобки). Семантика выполняется на уровне runtime/host.

| Язык | Примеры встроенных имен (лексически — идентификаторы) |
|---|---|
| Python | `print`, `input`, `len`, `open`, `int` — лексер помечает как NAME/IDENT |
| JavaScript | `console.log`, `alert`, `prompt` (браузер), глобальные объекты `Math`, `JSON` — лексер: IDENT, ".", IDENT |

**Пояснение:**  
- В Python `print` вывод — это просто имя-функция; лексер увидит `NAME` `print` и `(` — вызов.  
- В JS `console.log` лексически разбивается на `IDENT` `.` `IDENT`; конкретную семантику предоставляет среда выполнения (браузер, Node.js).  
- Для реализации лексера: достаточно корректно распознавать идентификаторы, точки, скобки и запятые. Разрешение имен — на этапе парсинга/семантики.

---

## 3. Пользовательские функции, включая параметры и возвращаемые значения

Лексически функция — это последовательность токенов: ключевое слово объявления, имя, `(` параметры `)`, тело.

### Python — пример
```python
def add(a, b=0):
    return a + b

x = add(2, b=3)
```
- Поддерживается: позиционные параметры, именованные параметры (b=3), значения по умолчанию.
- Лексер выделит `def`, имя, скобки, идентификаторы и знак `=` для default-значений.

### JavaScript — пример
```javascript
function add(a, b = 0) {
  return a + b;
}

const add2 = (a, b = 0) => a + b;
let x = add(2, 3);
```
- Поддерживается: параметры по умолчанию, rest-параметры `...args` (лексически — `...`), стрелочные функции (`=>` — отдельный токен).
- `return` — ключевой токен в обоих языках.

---

## 4. Встроенные типы данных: целые, числа с плавающей точкой и строки

### Сравнительная таблица литералов

| Тип | Python | JavaScript |
|---|---:|---|
| Целые | `123`, `0b101`, `0o77`, `0xFF`, разделитель `_` | `123`, `0b101`, `0o77`, `0xFF`, `_` разделитель, `123n` (BigInt) |
| Вещественные | `3.14`, `1e-9` | `3.14`, `1e-9` (Number — double precision) |
| Строки | `'...'`, `"..."`, '''...''', `"""..."""`, префиксы `r`, `f`, `b` | `'...'`, `"..."`, ` `...${expr}...` ` (template literal — интерполяция) |

**Примечания**
- В Python тройные кавычки — один многострочный токен; f-strings (`f"..."`) содержат вложенные выражения `{}`.  
- В JS шаблоны backtick переключают лексер в режим с вложенными `${...}` выражениями.  
- Суффикс `n` в JS отличает BigInt; лексер обязан поддержать этот суффикс.

---

## 5. Выражения с операторами

### Арифметические операторы

| Оператор | Python | JavaScript |
|---:|:---:|:---:|
| Сложение | `+` | `+` |
| Вычитание | `-` | `-` |
| Умножение | `*` | `*` |
| Деление | `/` (float), `//` (floor) | `/` (float) |
| Остаток | `%` | `%` |
| Степень | `**` | `**` |

### Логические операторы

| Оператор | Python | JavaScript |
|---|---:|---|
| И | `and` (keyword) | `&&` |
| ИЛИ | `or` | `||` |
| НЕ | `not` | `!` |

### Операторы сравнения

| Оператор | Python | JavaScript |
|---|---:|---|
| Равенство | `==`, `!=` | `==`, `!=`, `===`, `!==` |
| Отношения | `<`, `>`, `<=`, `>=` | `<`, `>`, `<=`, `>=` |

**Лексика:** многосимвольные токены (`===`, `!==`) должны быть распознаны по правилу максимальной жадности (maximal munch).

---

## 6. Пользовательские составные типы данных

### 6.1 Массивы / списки

| Язык | Литерал | Пример |
|---|---:|---|
| Python | Список: `[a, b, ...]` ; Кортеж: `(a, b)` | `lst = [1, 2, 3]` |
| JavaScript | Array: `[a, b, ...]` | `let arr = [1, 2, 3];` |

### 6.2 Структуры / записи / объекты

| Язык | Литерал | Пример |
|---|---:|---|
| Python | dict: `{ 'k': v, ... }` | `d = {'x': 1, 'y': 2}` |
| JavaScript | Object: `{ k: v, ... }` (shorthand, computed props, spread) | `let obj = { x: 1, y: 2 };` |

**Примечание:** фигурные скобки `{}` одинаковы лексически; различия — на парсере/семантике. JS требует поддержки дополнительных токенов `...`, `?.`, короткой записи полей.

## Вывод

- Python: лексика строится вокруг отступов и явных переводов строки — INDENT/DEDENT и NEWLINE — ключевые элементы.  
- JavaScript: лексика гибкая, много контекстных токенов (template literals, regex, ASI) и расширений ES — требует учитывать стандарт ES-версии.  

