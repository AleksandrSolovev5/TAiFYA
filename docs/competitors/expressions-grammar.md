# Сравнение синтаксиса выражений в Python и JavaScript

## 1. Сравнение числовых типов данных

### Python

- В Python 3 целых типов long как отдельного нет — есть int произвольной точности (arbitrary-precision)

```python
# Целые числа (int) - произвольной точности
x = 42
big_num = 123456789012345678901234567890

# Числа с плавающей точкой (float)
y = 3.14
z = 2.5e-3

# Комплексные числа
comp = 3 + 4j

```

### JavaScript

```javascript
// Все числа представлены типом Number (64-битные float)
let x = 42;
let y = 3.14;
let z = 2.5e-3;

// BigInt для больших целых чисел
let bigNum = 123456789012345678901234567890n;

// Отдельные специальные значения
let inf = Infinity;
let nan = NaN;
```

**Ключевые различия:**

- Python имеет раздельные типы `int` и `float`, JS использует единый `Number`
- Python поддерживает целые числа произвольной точности по умолчанию
- JS требует суффикс `n` для `BigInt`
- Python имеет встроенную поддержку комплексных чисел
- Логический тип bool в Python является подклассом int

## 2. Сравнение арифметических операторов

### Общие операторы

```
a + b    # сложение (также служит для конкатенации строк)
a - b    # вычитание
a * b    # умножение
a / b    # деление
a % b    # остаток от деления
a ** b   # возведение в степень
```

### Уникальные операторы

```python
# Только в Python
a // b   # целочисленное деление
a @ b    # оператор матричного умножения (3.5+)
```

```javascript
// Только в JavaScript
a++; // инкремент
a--; // декремент
++a; // префиксный инкремент
--a; // префиксный декремент
```

## 3. Сравнение приоритетов операций

### Python (высокий → низкий)

1. `()` `[]` `{}`
2. `**`
3. `+x` `-x` `~x` (унарные)
4. `*` `/` `//` `%`
5. `+` `-` (бинарные)
6. `<<` `>>`
7. `&`
8. `^`
9. `|`
10. `in` `not in` `is` `is not` `<` `<=` `>` `>=` `!=` `==`
11. `not`
12. `and`
13. `or`

### JavaScript (высокий → низкий)

1. `()` `[]` `.` `new`
2. `++` `--` (постфиксные)
3. `+` `-` `~` `!` `++` `--` (префиксные) `typeof` `void` `delete`
4. `**`
5. `*` `/` `%`
6. `+` `-`
7. `<<` `>>` `>>>`
8. `<` `<=` `>` `>=` `in` `instanceof`
9. `==` `!=` `===` `!==`
10. `&`
11. `^`
12. `|`
13. `&&`
14. `||`
15. `??`
16. `? :`
17. Присваивания

**Заметные различия:**

- `**` имеет высший приоритет в Python, но средний в JS
- Унарные операторы имеют разный приоритет относительно бинарных
- JS имеет больше операторов с особым приоритетом (`new`, `typeof`, `instanceof`)

## 4. Список лево- и правоассоциативных операторов

### Левоассоциативные (одинаково)

- `+` `-` `*` `/` `%`
- `<<` `>>`
- `&` `|` `^`
- `&&` `||`
- Сравнения

### Правоассоциативные (одинаково)

- `**` (в обоих языках)
- Присваивания (`=`, `+=`, etc.)

### Различия в ассоциативности

```python
# Python - тернарный оператор отсутствует
# Цепочка сравнений - особый случай
a < b < c   # Эквивалентно (a < b) and (b < c)
```

```javascript
// JavaScript - тернарный оператор правоассоциативен
a ? b : c ? d : e; // Парсится как a ? b : (c ? d : e)

// Цепочка сравнений работает иначе
a < b < c; // Парсится как (a < b) < c (обычно не то, что нужно)
```

## 5. Сравнение встроенных функций для работы с числами

### Python

```python
# Встроенные функции
abs(x)              # модуль
round(x[, n])       # округление
pow(x, y)           # возведение в степень
divmod(a, b)        # частное и остаток
max(iterable)       # максимум
min(iterable)       # минимум
sum(iterable)       # сумма
int(x)              # преобразование в int
float(x)            # преобразование в float
complex(re, im)     # создание комплексного числа

# Из модуля math
import math
math.floor(x)       # округление вниз
math.ceil(x)        # округление вверх
math.trunc(x)       # отбрасывание дробной части
math.isinf(x)       # проверка на бесконечность
math.isnan(x)       # проверка на NaN
```

- В Python math.inf, float('nan') — эквиваленты JS Infinity и NaN

### JavaScript

- Объект Math является встроенным объектом, хранящим в своих свойствах и методах различные математические константы и функции. Объект Math не является функциональным объектом.

- Math не работает с числами типа BigInt.

```javascript
// Глобальные функции
Math.abs(x); // модуль
Math.round(x); // округление
Math.floor(x); // округление вниз
Math.ceil(x); // округление вверх
Math.trunc(x); // отбрасывание дробной части
Math.pow(x, y); // возведение в степень
Math.max(...vals); // максимум
Math.min(...vals); // минимум
Math.random(); // случайное число

// Проверки
Number.isFinite(x); // проверка на конечное число
Number.isInteger(x); // проверка на целое число
Number.isNaN(x); // проверка на NaN
Number.isSafeInteger(x); // проверка на безопасное целое

// Преобразования
parseInt(str); // парсинг целого числа
parseFloat(str); // парсинг дробного числа
Number(str); // преобразование в число
```

- ВАЖНО! ParseInt() читает до первой некорректной цифры, Number() даёт NaN.

## 6. Прочие особенности синтаксиса выражений

### Обработка деления

```python
# Python 3
5 / 2      # 2.5 (всегда float)
5 // 2     # 2 (целочисленное деление)
```

```javascript
// JavaScript
5 / 2; // 2.5 (всегда Number)
5; // 2     // Синтаксическая ошибка!
```

### Неявные преобразования

```python
# Python - строгая типизация
"5" + 3    # TypeError!
"5" * 3    # умножение строки "5" 3 раза = "555"
```

```javascript
// JavaScript - слабая типизация
"5" + 3; // "53" (конкатенация)
"5" * 3; // 15 (неявное преобразование)
```

### Особенности сравнения

```python
# Python - строгое сравнение
0 == False   # True
"" == False  # False
None == 0    # False
```

```javascript
// JavaScript - нестрогое сравнение
0 == false; // true
"" == false; // true
null == 0; // false (особый случай)
"5" == 5; // true
null == undefined; // true

// Строгое сравнение
"5" === 5; // false
```

### Работа с большими числами

```python
# Python - автоматическая поддержка больших чисел
2 ** 1000  # Работает без проблем
```

```javascript
// JavaScript - требуется BigInt
2 ** 1000; // Infinity (переполнение)
2n ** 1000n; // Корректный результат с BigInt
```

- Операции между BigInt и Number запрещены без приведения типов

**Выводы:**

- Python имеет более богатую систему числовых типов
- JavaScript более либерален в преобразованиях, но это может приводить к ошибкам
- Приоритет операторов в целом похож, но есть важные различия
- Оба языка развиваются в направлении улучшения работы с числами (BigInt в JS, улучшения производительности в Python)
